# Design Documents for Badminton sports analysis

## Functional Design Document
```markdown
# Functional Design Document: Badminton Sports Analysis

## 1. Introduction and Purpose

This document outlines the functional design for a badminton sports analysis system.  The system aims to provide coaches and players with data-driven insights into their performance by analyzing video recordings of badminton matches.  The system will automatically track the shuttlecock, detect player movements, classify shots, and generate performance metrics. The ultimate goal is to improve player performance through detailed analysis of gameplay.

## 2. Project Scope

The scope of this project includes the development of a system capable of:

*   Ingesting video recordings of badminton matches.
*   Automatically detecting and tracking the shuttlecock trajectory.
*   Identifying player swing actions.
*   Estimating player pose and court position.
*   Segmenting rallies into individual shots.
*   Classifying shots into predefined categories (e.g., clear, drive, smash).
*   Calculating performance metrics (e.g., shot accuracy, hit timing).
*   Visualizing player positions, shuttlecock trajectories, and hit events.
*   Providing a user-friendly interface for accessing and analyzing the data.

The project excludes:

*   Live video analysis (only offline analysis of recorded matches).
*   Integration with external fitness trackers or wearable devices.
*   Automated player feedback or training recommendations.
*   Support for multi-camera setups.

## 3. User Roles and Permissions

The system will support the following user roles:

| Role        | Permissions                                                                                                                               |
|-------------|-------------------------------------------------------------------------------------------------------------------------------------------|
| Administrator | Full access to the system, including user management, data management, model training, and system configuration.                       |
| Coach       | Access to upload videos, analyze matches, view performance metrics, create and manage player profiles, and generate reports.               |
| Player      | Access to view their own performance metrics, analyze their own matches, and review reports generated by their coach.                      |
| Guest        | Limited access to view demo data and explore system features. Cannot upload or modify data. Requires no account.                        |

## 4. Functional Requirements Breakdown

This section details the functional requirements of the system, categorized for clarity.

### 4.1. Video Input and Processing

*   **FR.VIP.01:** The system shall accept video input in common formats (e.g., MP4, AVI, MOV).
*   **FR.VIP.02:** The system shall allow users to upload video files via a web interface.
*   **FR.VIP.03:** The system shall automatically process the video to extract relevant features (shuttlecock trajectory, player movements).
*   **FR.VIP.04:** The system shall handle videos with varying frame rates and resolutions.
*   **FR.VIP.05:** The system shall provide feedback to the user on the progress of video processing.
*   **FR.VIP.06:** The system shall log any errors encountered during video processing.

### 4.2. Shuttlecock Tracking

*   **FR.ST.01:** The system shall accurately track the shuttlecock throughout the video.
*   **FR.ST.02:** The system shall use a robust tracking algorithm (e.g., TrackNet) to handle occlusions and fast movements.
*   **FR.ST.03:** The system shall smooth the shuttlecock trajectory to reduce noise and improve accuracy.
*   **FR.ST.04:** The system shall output the shuttlecock's position (x, y coordinates) in each frame.
*   **FR.ST.05:** The system shall handle cases where the shuttlecock is not visible (e.g., out of bounds).

### 4.3. Player Swing Detection

*   **FR.PSD.01:** The system shall detect player swing actions with high confidence.
*   **FR.PSD.02:** The system shall use a detection model (e.g., YOLOv7) to identify swing events.
*   **FR.PSD.03:** The system shall output the timestamp and bounding box coordinates of each detected swing.
*   **FR.PSD.04:** The system shall allow users to adjust the confidence threshold for swing detection.

### 4.4. Human Pose Estimation

*   **FR.HPE.01:** The system shall estimate the pose of each player in each frame.
*   **FR.HPE.02:** The system shall use a pose estimation system (e.g., DensePose) to track player joints.
*   **FR.HPE.03:** The system shall transform player joint coordinates to a top-down plane view of the court.
*   **FR.HPE.04:** The system shall output the coordinates of key joints (e.g., ankles, wrists) for each player.

### 4.5. Shot Refinement Algorithm (SRA)

*   **FR.SRA.01:** The system shall fuse shuttlecock trajectory and swing action detection to accurately determine hit moments.
*   **FR.SRA.02:** The system shall reduce false positives in hit moment detection.
*   **FR.SRA.03:** The system shall improve the precision of hit moment detection.
*   **FR.SRA.04:** The system shall output the timestamp of each refined hit moment.

### 4.6. Shot Segmentation and Classification

*   **FR.SSC.01:** The system shall segment continuous rallies into discrete shots.
*   **FR.SSC.02:** The system shall classify each shot into one of the following categories: clear, drive, smash, net, drop, lift, push.
*   **FR.SSC.03:** The system shall use displacement and timing features to classify shots.
*   **FR.SSC.04:** The system shall allow users to manually correct shot segmentation and classification.

### 4.7. Performance Metrics Evaluation

*   **FR.PME.01:** The system shall compute metrics such as precision, recall, and F1-score for shot detection.
*   **FR.PME.02:** The system shall use t-IoU (temporal intersection over union) for hit moment alignment.
*   **FR.PME.03:** The system shall calculate other relevant performance metrics, such as shot accuracy, hit timing, and player movement speed.
*   **FR.PME.04:** The system shall display performance metrics in a clear and concise format.

### 4.8. Visualization Module

*   **FR.VM.01:** The system shall provide a graphical representation of player positions, shuttlecock trajectories, and hit events.
*   **FR.VM.02:** The system shall allow users to visualize the data in 2D and 3D views.
*   **FR.VM.03:** The system shall allow users to zoom in and out of the visualization.
*   **FR.VM.04:** The system shall allow users to filter the data based on shot type, player, and other criteria.
*   **FR.VM.05:** The system shall allow users to export the visualization as an image or video file.

### 4.9. User Interface

*   **FR.UI.01:** The system shall provide a user-friendly web interface.
*   **FR.UI.02:** The system shall be accessible on desktop and mobile devices.
*   **FR.UI.03:** The system shall be responsive and performant.
*   **FR.UI.04:** The system shall provide clear and concise instructions for using the system.

## 5. User Interface Design Guidelines

*   **Consistency:** Maintain a consistent look and feel throughout the application. Use a common set of UI elements and patterns.
*   **Clarity:** Use clear and concise language. Avoid jargon and technical terms.
*   **Efficiency:** Design the interface to be efficient and easy to use. Minimize the number of clicks required to perform common tasks.
*   **Feedback:** Provide feedback to the user on their actions. Let them know when a task is complete or if an error has occurred.
*   **Accessibility:** Design the interface to be accessible to users with disabilities. Follow accessibility guidelines.
*   **Visual Hierarchy:** Use visual cues to guide the user's attention and highlight important information.

## 6. Business Process Flows

### 6.1. Video Analysis Workflow

1.  **User Uploads Video:** A coach or administrator uploads a video file of a badminton match.
2.  **System Processes Video:** The system automatically processes the video using the shuttlecock tracking, player swing detection, and pose estimation algorithms.
3.  **Shot Segmentation and Classification:** The system segments the rally into individual shots and classifies each shot.
4.  **Performance Metrics Calculation:** The system calculates performance metrics based on the extracted data.
5.  **Data Visualization:** The system generates visualizations of player positions, shuttlecock trajectories, and hit events.
6.  **User Review and Analysis:** The coach or player reviews the data and visualizations to analyze performance.
7.  **Report Generation:** The coach generates a report summarizing the key findings.

### 6.2. User Management Workflow

1.  **Administrator Creates User Account:** An administrator creates a new user account with the appropriate role (coach, player, administrator).
2.  **User Logs In:** The user logs in to the system using their username and password.
3.  **User Accesses Features:** The user accesses the features appropriate to their role.
4.  **Administrator Manages Users:** The administrator can modify user roles, reset passwords, and delete user accounts.

## 7. Data Entities and Relationships

| Entity        | Attributes                                                                                                                               | Relationships                                                                                                                                                                                                                                                           |
|---------------|-------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| User          | UserID (PK), Username, Password, Email, Role                                                                                               | One-to-many relationship with Video.  One-to-many relationship with Reports.                                                                                                                                                                                               |
| Video         | VideoID (PK), UserID (FK), Filename, UploadDate, ProcessingStatus                                                                          | Many-to-one relationship with User.  One-to-many relationship with Shot.                                                                                                                                                                                                  |
| Shot          | ShotID (PK), VideoID (FK), StartTime, EndTime, ShotType, HitMoment                                                                         | Many-to-one relationship with Video. One-to-many relationship with ShuttlecockTrajectory.  One-to-many relationship with PlayerPosition                                                                                                                                             |
| ShuttlecockTrajectory | TrajectoryID (PK), ShotID (FK), FrameNumber, XCoordinate, YCoordinate                                                                    | Many-to-one relationship with Shot.                                                                                                                                                                                                                                |
| PlayerPosition | PositionID (PK), ShotID (FK), FrameNumber, PlayerID, XCoordinate, YCoordinate                                                               | Many-to-one relationship with Shot.                                                                                                                                                                                                                                |
| Report        | ReportID (PK), UserID (FK), VideoID (FK), GenerationDate, Content                                                                             | Many-to-one relationship with User. One-to-one relationship with Video (optional, report can be generated from multiple videos or aggregated data).                                                                                                                            |
| Player        | PlayerID (PK), PlayerName, Team                                                                                                             | Many-to-many relationship with Video (through a separate table, e.g., `VideoPlayer`).  Allows tracking which players participated in a given video.  This relationship is not directly represented in the table but implied by the PlayerPosition and Video entities. |

(PK = Primary Key, FK = Foreign Key)

## 8. Validation Rules

*   **Video Upload:**  Video files must be in a supported format (MP4, AVI, MOV).  The file size must be within the allowed limit.
*   **User Registration:**  Username and email must be unique.  Password must meet minimum complexity requirements.
*   **Shot Classification:** Shot type must be selected from a predefined list of categories.
*   **Data Integrity:**  Foreign key relationships must be enforced to maintain data consistency.
*   **Input Sanitization:**  All user inputs must be sanitized to prevent SQL injection and cross-site scripting attacks.

## 9. Reporting Requirements

The system shall provide the following reports:

*   **Shot Type Distribution Report:**  A report showing the percentage of each shot type used by a player in a match.
*   **Hit Timing Report:** A report showing the average hit timing for each shot type.
*   **Shot Accuracy Report:** A report showing the accuracy of each shot type.
*   **Player Movement Report:** A report showing the average distance covered by a player during a match.
*   **Comparison Report:**  A report comparing the performance of two players or two matches.
*   **Custom Report:** Allow coaches to define and generate custom reports based on specific criteria.

Reports should be exportable in PDF and CSV formats.

## 10. Integration Points

*   **Database:** The system will integrate with a relational database (e.g., PostgreSQL, MySQL) to store data.
*   **Deep Learning Frameworks:** The system will utilize deep learning frameworks (e.g., TensorFlow, PyTorch) for shuttlecock tracking, player swing detection, and pose estimation.
*   **Cloud Storage:** The system can integrate with cloud storage services (e.g., AWS S3, Google Cloud Storage) to store video files and processed data.
```

## Technical Design Document
```markdown
# Technical Design Document: Badminton Sports Analysis

## 1. System Architecture

This system aims to provide comprehensive analysis of badminton matches using video input. The architecture is composed of several key modules that work together to process video, extract relevant information, and present it in a user-friendly manner.

**Diagram (Conceptual):**

```
[Video Input] --> [Preprocessing] --> [Shuttlecock Tracking] --> [Player Swing Detection] --> [Human Pose Estimation] --> [Shot Refinement] --> [Shot Segmentation & Classification] --> [Performance Metrics] --> [Visualization] --> [User Interface]
```

**Modules:**

*   **Video Input:** Receives video feeds from various sources (e.g., cameras, recorded files).
*   **Preprocessing:** Handles video decoding, frame extraction, and resolution adjustment.
*   **Shuttlecock Tracking:** Detects and tracks the shuttlecock's trajectory using a deep learning model.
*   **Player Swing Detection:** Identifies player swing actions using object detection.
*   **Human Pose Estimation:** Tracks player joints to understand player positions and movements.
*   **Shot Refinement:** Combines shuttlecock tracking and swing detection to accurately identify hit moments.
*   **Shot Segmentation & Classification:** Segments rallies into individual shots and classifies them into different types.
*   **Performance Metrics:** Calculates relevant performance metrics based on extracted data.
*   **Visualization:** Generates graphical representations of player movements, shuttlecock trajectories, and hit events.
*   **User Interface:** Provides a platform for users to interact with the system, view analysis results, and customize settings.

## 2. Technology Stack and Justification

| Technology       | Purpose                                                              | Justification                                                                                                                                                                                                                                                                                                                         |
| ---------------- | -------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Python           | Core programming language                                             | Widely used in data science and machine learning, with extensive libraries for image processing, numerical computation, and deep learning.                                                                                                                                                                                       |
| TensorFlow/PyTorch | Deep learning framework                                              | TensorFlow and PyTorch offer robust tools for building and training deep learning models for shuttlecock tracking, player swing detection, and human pose estimation. TensorFlow is known for production readiness, while PyTorch is more research-friendly. The choice will depend on specific model needs and deployment preferences. |
| OpenCV           | Computer vision library                                               | Used for video processing, image manipulation, and feature extraction.                                                                                                                                                                                                                                                            |
| NumPy            | Numerical computation library                                          | Provides efficient array operations for data manipulation and analysis.                                                                                                                                                                                                                                                              |
| Pandas           | Data analysis library                                               | Used for data manipulation, cleaning, and analysis.                                                                                                                                                                                                                                                                                |
| TrackNet         | Shuttlecock Tracking Model                                             | A state-of-the-art model specifically designed for tracking badminton shuttlecocks in video. Provides high accuracy and robustness.                                                                                                                                                                                                  |
| YOLOv7           | Object Detection Model (Player Swing Detection)                       | A fast and accurate object detection model that can be used to identify player swing actions.                                                                                                                                                                                                                                  |
| DensePose        | Human Pose Estimation Model                                           | Provides accurate 3D human pose estimation from images, allowing for tracking player joint positions.                                                                                                                                                                                                                                 |
| Flask/FastAPI    | Web framework (for API)                                               | Used to create a RESTful API for accessing analysis results and integrating with other applications. Flask is lightweight and flexible, while FastAPI offers automatic data validation and API documentation.                                                                                                                |
| PostgreSQL       | Database                                                             | A robust and scalable relational database to store match data, analysis results, and user information.                                                                                                                                                                                                                           |
| Redis            | Caching                                                              | For caching frequently accessed data and model predictions to improve performance.                                                                                                                                                                                                                                            |
| Docker           | Containerization                                                       | Used to package the application and its dependencies into containers for easy deployment and portability.                                                                                                                                                                                                                          |

## 3. Database Schema

The database will store information about matches, players, shots, and analysis results.

**Tables:**

*   **Matches:**
    *   `match_id` (INT, PRIMARY KEY)
    *   `match_date` (DATE)
    *   `team1_player1_id` (INT, FOREIGN KEY referencing Players)
    *   `team1_player2_id` (INT, FOREIGN KEY referencing Players) (Optional, for doubles)
    *   `team2_player1_id` (INT, FOREIGN KEY referencing Players)
    *   `team2_player2_id` (INT, FOREIGN KEY referencing Players) (Optional, for doubles)
    *   `video_path` (VARCHAR)
    *   `location` (VARCHAR)

*   **Players:**
    *   `player_id` (INT, PRIMARY KEY)
    *   `player_name` (VARCHAR)
    *   `player_team` (VARCHAR)

*   **Shots:**
    *   `shot_id` (INT, PRIMARY KEY)
    *   `match_id` (INT, FOREIGN KEY referencing Matches)
    *   `rally_id` (INT)  // shot number within a rally
    *   `shot_number` (INT) // shot number in the entire match
    *   `player_id` (INT, FOREIGN KEY referencing Players) // Player who hit the shot
    *   `shot_type` (VARCHAR) // e.g., "Clear", "Smash", "Drop"
    *   `hit_timestamp` (FLOAT) // Timestamp (seconds) of the hit moment in the video
    *   `start_x` (FLOAT) // Shuttlecock x coordinate at start
    *   `start_y` (FLOAT) // Shuttlecock y coordinate at start
    *   `end_x` (FLOAT)   // Shuttlecock x coordinate at end
    *   `end_y` (FLOAT)   // Shuttlecock y coordinate at end
    *   `swing_confidence` (FLOAT) // confidence score from swing detection model
    *   `trajectory_data` (JSON) // JSON object containing the shuttlecock's trajectory data (x, y coordinates for each frame)

*   **Rallies:**
    *   `rally_id` (INT, PRIMARY KEY)
    *   `match_id` (INT, FOREIGN KEY referencing Matches)
    *   `start_timestamp` (FLOAT) // Timestamp (seconds) of the rally start
    *   `end_timestamp` (FLOAT)   // Timestamp (seconds) of the rally end
    *   `winner_player_id` (INT, FOREIGN KEY referencing Players) // Player who won the rally

**Relationships:**

*   One-to-many: Matches to Shots, Matches to Rallies
*   Many-to-one: Shots to Players, Rallies to Players

## 4. API Specifications

The API will provide endpoints for accessing match data, analysis results, and performing specific analysis tasks.

**Endpoints:**

*   `/matches` (GET): Returns a list of matches.
    *   Parameters: `limit`, `offset`, `date_from`, `date_to`
    *   Response: JSON array of match objects.

*   `/matches/{match_id}` (GET): Returns details of a specific match.
    *   Response: JSON object containing match details, player information, and analysis summary.

*   `/matches/{match_id}/shots` (GET): Returns a list of shots for a specific match.
    *   Parameters: `limit`, `offset`, `player_id`, `shot_type`
    *   Response: JSON array of shot objects.

*   `/matches/{match_id}/rallies` (GET): Returns a list of rallies for a specific match.
    *   Parameters: `limit`, `offset`, `winner_player_id`
    *   Response: JSON array of rally objects.

*   `/analyze` (POST): Submits a video for analysis.
    *   Request: Multipart form data containing the video file.
    *   Response: JSON object containing the analysis job ID.

*   `/analysis/{job_id}` (GET): Returns the status and results of an analysis job.
    *   Response: JSON object containing the job status (e.g., "pending", "running", "completed", "failed") and analysis results (if completed).

**Example (JSON Response for a Shot):**

```json
{
  "shot_id": 123,
  "match_id": 456,
  "rally_id": 10,
  "shot_number": 15,
  "player_id": 789,
  "shot_type": "Smash",
  "hit_timestamp": 12.5,
  "start_x": 100.0,
  "start_y": 50.0,
  "end_x": 300.0,
  "end_y": 150.0,
  "swing_confidence": 0.95,
  "trajectory_data": [{"frame": 100, "x": 100.0, "y": 50.0}, {"frame": 101, "x": 105.0, "y": 55.0}, ...]
}
```

## 5. Security Considerations

*   **Authentication and Authorization:** Implement authentication mechanisms (e.g., API keys, JWT) to control access to the API endpoints.  Use role-based access control (RBAC) to restrict access based on user roles (e.g., admin, coach, player).
*   **Input Validation:** Validate all user inputs to prevent injection attacks and ensure data integrity.
*   **Data Encryption:** Encrypt sensitive data at rest and in transit. Use HTTPS for API communication.
*   **Rate Limiting:** Implement rate limiting to prevent abuse and ensure availability of the system.
*   **Regular Security Audits:** Conduct regular security audits to identify and address potential vulnerabilities.
*   **Video Storage Security:** Implement secure storage for video files with access controls and encryption.

## 6. Performance Considerations

*   **Model Optimization:** Optimize deep learning models for inference speed. Consider using techniques like model quantization, pruning, and knowledge distillation.
*   **Caching:** Implement caching mechanisms (e.g., Redis) to store frequently accessed data and model predictions.
*   **Asynchronous Processing:** Use asynchronous processing for long-running tasks like video analysis to avoid blocking the API. Use Celery or similar task queues.
*   **Database Optimization:** Optimize database queries and indexing for efficient data retrieval.
*   **Load Balancing:** Use load balancing to distribute traffic across multiple servers.
*   **Resource Monitoring:** Monitor system resource usage (CPU, memory, disk I/O) to identify bottlenecks and optimize performance.

## 7. Scalability Approach

*   **Horizontal Scaling:** Design the system to be horizontally scalable by adding more servers to handle increased load.
*   **Microservices Architecture:** Consider a microservices architecture to decompose the system into smaller, independent services that can be scaled independently.
*   **Database Sharding:** Implement database sharding to distribute data across multiple database servers.
*   **Cloud-Based Infrastructure:** Leverage cloud-based infrastructure (e.g., AWS, Azure, GCP) to provide scalability and elasticity.
*   **Containerization and Orchestration:** Use Docker and Kubernetes to containerize and orchestrate the application for easy deployment and scaling.

## 8. Deployment Strategy

*   **Continuous Integration/Continuous Deployment (CI/CD):** Implement a CI/CD pipeline to automate the build, testing, and deployment process.
*   **Containerization:** Use Docker to package the application and its dependencies into containers.
*   **Orchestration:** Use Kubernetes to orchestrate the deployment, scaling, and management of containers.
*   **Infrastructure as Code (IaC):** Use IaC tools (e.g., Terraform, CloudFormation) to manage the infrastructure in a declarative way.
*   **Blue/Green Deployment:** Use blue/green deployment to minimize downtime during deployments.
*   **Monitoring and Logging:** Implement comprehensive monitoring and logging to track system health and performance.

## 9. Third-Party Integrations

*   **Object Storage (AWS S3, Google Cloud Storage):**  For storing video files and analysis results.
*   **Message Queue (RabbitMQ, Kafka):**  For asynchronous task processing and inter-service communication.
*   **Cloud Monitoring (Prometheus, Grafana):** For monitoring system health and performance.
*   **Logging (ELK Stack, Splunk):** For collecting and analyzing logs.
*   **Analytics Platforms (Google Analytics, Mixpanel):** For tracking user behavior and usage patterns.

## 10. Development, Testing, and Deployment Environments

*   **Development Environment:** Local development environments for individual developers, typically using Docker containers for consistency.
*   **Testing Environment:**  A dedicated environment for automated testing (unit, integration, and end-to-end tests).  This environment should closely mirror the production environment.
*   **Staging Environment:** A pre-production environment for final testing and user acceptance testing (UAT).
*   **Production Environment:** The live environment where the application is deployed and accessible to users.

**Testing Strategy:**

*   **Unit Tests:**  Test individual components and functions.
*   **Integration Tests:**  Test the interaction between different modules.
*   **End-to-End Tests:**  Test the entire system from the user's perspective.
*   **Performance Tests:**  Test the system's performance under load.
*   **Security Tests:**  Test the system for security vulnerabilities.

**Code Example (Python - Shuttlecock Tracking using TrackNet):**

```python
import cv2
import numpy as np
from tensorflow.keras.models import load_model

# Load the TrackNet model
model = load_model('tracknet_model.h5')  # Replace with your model path

# Load the video
video_path = 'badminton_match.mp4'
cap = cv2.VideoCapture(video_path)

# Get video dimensions
width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

# Initialize variables
frame_count = 0
previous_frames = []
trajectory = []

while True:
    ret, frame = cap.read()
    if not ret:
        break

    frame_count += 1

    # Preprocess the frame
    resized_frame = cv2.resize(frame, (224, 224))
    normalized_frame = resized_frame / 255.0

    # Prepare input for the model
    if len(previous_frames) < 8:
        previous_frames.append(normalized_frame)
        continue
    else:
        input_frames = np.array(previous_frames)
        input_frames = np.expand_dims(input_frames, axis=0) # Add batch dimension

    # Predict the shuttlecock position
    prediction = model.predict(input_frames)[0]  # remove batch dimension

    # Get the predicted coordinates
    predicted_x = int(prediction[0][0] * width)
    predicted_y = int(prediction[0][1] * height)

    # Store the trajectory
    trajectory.append((predicted_x, predicted_y))

    # Draw the trajectory on the frame
    for i in range(1, len(trajectory)):
        cv2.line(frame, trajectory[i - 1], trajectory[i], (0, 255, 0), 2)

    # Show the frame
    cv2.circle(frame, (predicted_x, predicted_y), 5, (0, 0, 255), -1) #red circle at prediction

    cv2.imshow('Badminton Analysis', frame)

    # Update previous frames
    previous_frames.pop(0)
    previous_frames.append(normalized_frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
```
```